# syx
To run:
- Open the solution.
- Select Win32.App as the startup project.
- Enter the following as command arguments in Win32.App project settings for running through visual studio `projectRoot=D:\syx\syx\data loadScene=D:\syx\syx\data\scene.json`

# Communication between systems
Systems should be able to replicate the state they care about via subscribing to relevant messages in the message queue. At the moment systems can still access other systems directly, but ultimately this should  be phased out in favor of improving message channels to the point that it's easy to request whatever is needed from other systems. All messages are pushed to a global message queue that is swapped every frame. This means any messages sent during a frame will be processed the next frame. Whenever any state is changed that any other system may care about, like Transform, messages should be used to request the change to state, then the message handler on the relevant system should apply the change. If desired, the system could also proactively apply the change and ignore messages from itself.

Currently Graphics and Physics systems are listening to transform events as well as modifications to the Renderable and Physics component properties respectively. They use this to fill their local object maps. The LuaGameSystem is the only system that keeps track of all components on all objects, for the purposes of making them available to scripts. It would currently be difficult to replicate state if a system conditionally started listening for events, as there's currently no way to query for all parts of a game object.

# LuaGameSystem
This holds all game objects so they can be referenced by scripts, and is responsible for running said scripts. During a gameplay update script contexts are batched between multiple threads. Each has immutable access to the game objects, and sends messages when it wants to change properties on objects, which will apply next frame. I will likely introduce thread local state so that within a context the frame gap is not visible if a property is set then immediately retreived. This is currently what happens for adding components, but should be extended for property modifications as well.

Metadata about types is expressed through Lua::Node, which wraps the type itself, as well as any operation that needs to be done on it like construction, destruction, and assigment. This is what is used to simplify the sending of property changes through messages. All relevant properties should be expressed via Lua Nodes in MyComponent::getTypeInfo. This builds a tree that can which can be traversed via pointer offsets to compute differences and serialize them to a buffer. So to send message that requests a change of a property on a component, you can make a copy of the component, change the property, compute the diff of the two using the Lua::Node, then serialize the new values into the SetComponentPropsEvent with the diff id which can be used to only apply the relevant changes on the other end. This is in part to protect against multiple events modifying the same Component in the same frame. If they modify different properties, then they won't stomp each-other because the diff will only apply to the single property that was changed instead of the entire component. If two events set the same component then of course it's a race condition. The **ComponentPublisher** formalizes this process within LuaGameSystem to help discourage accidental unsafe modification of the objects outside of the message loop.

This metadata is also used to populate default editor widgets for well known types, and additional context can be added by attaching custom editor information to the property registration.

# Loading assets
Assets are currently loaded by registering an AssetLoader which corresponds to a particular AssetType and file extension. In code then these assets can be retrieved via access to the AssetRepo system. An asset handle will be available immediately while the asset load process is known via an enum on the asset. This process is a bit clunky at the moment, lacking a reasonable error mechanism for missing asseets. This would benefit from events when loading finishes and possibly a future as well for the asset handle. Or maybe both could be accomplished by creating a message wrapper that wraps the awaiting of a message in a future.

# Saving and loading scenes
The lua nodes of all objects in LuaGameSystem are used to serialize all properties of a scene to an executable lua file. When saving the file the system notes all assets that are needed and puts then in a separate section of the file so that the assets can be loaded as part of loading the scene.

# Exposing methods to the scripting layer
Each component has a virtual openLib function that can declare all the members of what is exposed about this component to the scripting layer. The object's properties are automatically exposed as `self.propertyName = value` by the information provided by the Component's `Lua::Node`s. Additional methods are exposed manually with function pointers. `self` will result in the `this` pointer being availabe on the lua stack which can be retreived with `Component::_checkSelf`. This returns a `ComponentPublisher`, reinforcing the idea that the game objects should be immutable while scripts are running, so any methods that wish to modify logic should use the publisher to send messages that will be applied next frame. The heavy coupling with lua for this is not great, but coming up with an abstraction layer is a low priority for me.

# Multithreading of gameplay scripts
The current approach is for all state accessible to lua to be immutable during the gameplay update. Then multiple threads can access the immutable data at the same time. This is encouraged with the `ComponentPublisher` which exposes const versions of the components with a method to send updates through as messages. These updates are then applied on the next frame. Without an additional mechanism it's very easy for this delayed update to cause confusion in the script because setting and immediately getting a value will not reflect the new value. The transform component is also problematic in this way since its only property is a single matrix, so any change to that matrix would stomp any other. In other words, setting position then scale would result in only a change to scale. The solution to this is to allow thread local state to retain updates caused by this thread until the next frame where they are officially applied. This still means separate threads won't know of each-others changes until the next frame, but in most cases that should be fine. If multiple scripts want to modify the same object they should send messages to the object because all messages will be processed in the same context.

For objects in the scripting layer this should be enforced by only the self object being modifiable, and all other mutation must be done through messaging. The way modifications are exposed to the scripting layer without causing accidental modification is that the `ILuaGameContext` responsible for updating an object doesn't push the object istelf, but an `IGameObject`. The implementation of this reflects state of either the actual object as owned by `LuaGameSystem` or the pending thread-local state as owned by the `ILuaGameContext`. The same idea applies for `IComponent`, which exposes const access to an underlying `Component` which is either the actual one or the context-local version. Mutation of the component goes through this interface as well, which will perform the change immediately on the context's component, and send a message for the rest of the engine to hear about it.

A different implementation which would provide the same effect is to have non-mutable state but have multiple luagamesystems that can each update in parallel. The downside to this would be duplication, and extra overhead of message processing.

Alternatively state could be mutable and multithreaded, meaning modifications would require locks. This may be fine for some cases, but certain patterns like having a master control object in scripts may cause very high contention. The complexity of the locking mechanism may also spiral out of control in terms of implementation complexity to avoid deadlocks.

# Creation of game objects and selection of their ids
All systems must be able to agree on a set of ids to be able to communicate state on gameobjects to each-other. For this purpose, a runtime ID consisting of an incrementing atomic count can be used. However, this doesn't work well for persisting ids in saved scenes, as ids would change every time the scene is saved after being reloaded. Even worse, it would make having game object references between objects difficult, as they would constantly have to update references upon each reload, adding potential for desyncs.

For this purpose, a stable globally unique id is needed for objects, which persists across scene reloads. This raises the question of how systems should go about restoring a known object with a given id. In theory, multiple systems could try to create the same object (based on unique id) on the same frame. If unique ids are used exclusively for objects, then this situation behaves as expected, provided that every system is able to handle the duplicate add component events, which they should. If only runtime ids are communicated between systems, then this is a problem, because now there are two objects with different runtime ids but the same unique id. To prevent such a situation, sytems would need a mechanism to claim ids before being sure if they can create the object or if it already exists. This also leaves the possibility for error on the creator, if they fail to make sure the id they're trying to create wasn't already claimed.

Even if all systems communicated entirely with unique ids, there's still a question of how to generate new ones. If they are generated randomly, then collisions can almost entirely be avoided assuming the generator is good and the numer is large enough. If there was a collision, two different objects now use the same id, which is problematic. So regardless of if runtime ids are used in combination with unique ids, or unique ids are used in isolation, it's still helpful to have a global registry of claimed ids so that the creator can choose their error handling explicitly.