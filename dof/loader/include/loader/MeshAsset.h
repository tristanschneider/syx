#pragma once

#include "glm/vec2.hpp"

//Assimp exports the mesh with its uvs and material, meaning the same
//shape with different UVs requires two models.
//To allow efficient instancing, models and uvs are deduplicated so they don't
//match Assimp output directly but can allow for less final data needed on the gpu for shared shapes,
//which is the majority of models in the game
namespace Loader {
  struct MeshVertex {
    auto operator<=>(const MeshVertex&) const = default;

    //Matches the mesh data seen in blender with the Z axis ignored
    glm::vec2 pos{};
    //Matches UV data from blender as-is
    glm::vec2 uv{};
  };
  struct MeshAsset {
    auto operator<=>(const MeshAsset&) const = default;

    std::vector<MeshVertex> verts;
  };

  //Index into the meshes of the scene. Automatically generated by export/import process
  struct MeshIndex {
    auto operator<=>(const MeshIndex&) const = default;

    constexpr bool isSet() const {
      return *this != MeshIndex{};
    }

    static constexpr uint32_t INVALID = std::numeric_limits<uint32_t>::max();
    uint32_t meshIndex = INVALID;
    uint32_t materialIndex = INVALID;
  };
}

namespace std {
  template<>
  struct hash<Loader::MeshAsset> {
    size_t operator()(const Loader::MeshAsset& v) const;
  };
};