#pragma once

#include "glm/vec2.hpp"

//Assimp exports the mesh with its uvs and material, meaning the same
//shape with different UVs requires two models.
//To allow efficient instancing, models and uvs are deduplicated so they don't
//match Assimp output directly but can allow for less final data needed on the gpu for shared shapes,
//which is the majority of models in the game
namespace Loader {
  struct MeshVerticesAsset {
    auto operator<=>(const MeshVerticesAsset&) const = default;
    //Matches the mesh data seen in blender with the Z axis ignored
    std::vector<glm::vec2> vertices;
  };

  struct MeshUVsAsset {
    auto operator<=>(const MeshUVsAsset&) const = default;
    //Matches UV data from blender as-is
    std::vector<glm::vec2> textureCoordinates;
  };

  //Index into the meshes of the scene. Automatically generated by export/import process
  struct MeshIndex {
    auto operator<=>(const MeshIndex&) const = default;

    constexpr bool isSet() const {
      return *this != MeshIndex{};
    }

    static constexpr uint32_t INVALID = std::numeric_limits<uint32_t>::max();
    uint32_t verticesIndex = INVALID;
    uint32_t uvsIndex = INVALID;
    uint32_t materialIndex = INVALID;
  };
}

namespace std {
  template<>
  struct hash<Loader::MeshVerticesAsset> {
    size_t operator()(const Loader::MeshVerticesAsset& v) const;
  };

  template<>
  struct hash<Loader::MeshUVsAsset> {
    size_t operator()(const Loader::MeshUVsAsset& v) const;
  };
};